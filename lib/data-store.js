// Generated by CoffeeScript 1.8.0
(function() {
  var DataStore, DataStoreController, DataStoreModel, DataStoreRegistry, EventEmitter, SR, assert, bunyan,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  assert = require('assert');

  bunyan = require('bunyan');

  SR = require('stormregistry');

  DataStoreRegistry = (function(_super) {
    __extends(DataStoreRegistry, _super);

    function DataStoreRegistry(entity, opts) {
      var datadir, _ref, _ref1;
      this.entity = entity;
      assert(entity instanceof Object && (entity.model != null), "cannot construct DataStoreRegistry without valid entity passed in");
      this.store = opts != null ? opts.store : void 0;
      this.log = opts != null ? (_ref = opts.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.on('load', function(key, val) {
        var entry;
        this.log.debug({
          entity: this.entity.name,
          key: key
        }, 'loading a persisted record');
        entry = val != null ? val[this.entity.name] : void 0;
        if (entry != null) {
          entry.id = key;
          entry.saved = true;
          return this.add(key, entry);
        }
      });
      this.on('ready', function() {
        var _ref1;
        return this.log.info({
          entity: this.entity.name,
          size: (_ref1 = Object.keys(this.entries)) != null ? _ref1.length : void 0
        }, 'registry is initialized and ready');
      });
      datadir = (_ref1 = opts != null ? opts.datadir : void 0) != null ? _ref1 : '/tmp';
      DataStoreRegistry.__super__.constructor.call(this, {
        log: this.log,
        path: entity.persist ? "" + datadir + "/" + entity.name + ".db" : void 0
      });
    }

    DataStoreRegistry.prototype.keys = function() {
      return Object.keys(this.entries);
    };

    DataStoreRegistry.prototype.get = function(id) {
      var entry;
      entry = DataStoreRegistry.__super__.get.call(this, id);
      if (entry == null) {
        return null;
      }
      if (!(entry instanceof DataStoreModel)) {
        this.update(id, new this.entity.model(entry, {
          store: this.store,
          log: this.log
        }));
      }
      return DataStoreRegistry.__super__.get.call(this, id);
    };

    return DataStoreRegistry;

  })(SR);

  DataStoreModel = (function(_super) {
    var async, extend, uuid;

    __extends(DataStoreModel, _super);

    async = require('async');

    extend = require('util')._extend;

    uuid = require('node-uuid');

    DataStoreModel.prototype.schema = null;

    DataStoreModel.prototype.store = null;

    function DataStoreModel(data, opts) {
      var check, key, name, prop, val, violations, _ref, _ref1, _ref2, _ref3, _ref4;
      this.properties = {
        createdOn: {
          value: null
        },
        modifiedOn: {
          value: null
        },
        accessedOn: {
          value: null
        }
      };
      this.isSaved = false;
      this.store = opts != null ? opts.store : void 0;
      this.log = opts != null ? (_ref = opts.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.log.debug({
        data: data
      }, "constructing " + this.name);
      _ref1 = this.schema;
      for (key in _ref1) {
        val = _ref1[key];
        if (this.schema != null) {
          (function(_this) {
            return (function(val) {
              return _this.properties[key] = extend({}, val);
            });
          })(this)(val);
        }
      }
      this.id = data != null ? data.id : void 0;
      if (this.id == null) {
        this.id = uuid.v4();
      }
      if (this.version == null) {
        this.version = 1;
      }
      this.setProperties(data);
      violations = [];
      _ref2 = this.properties;
      for (name in _ref2) {
        prop = _ref2[name];
        if (prop.value == null) {
          prop.value = (_ref3 = prop.opts) != null ? _ref3.defaultValue : void 0;
        }
        if (!prop.value) {
          if ((_ref4 = prop.opts) != null ? _ref4.required : void 0) {
            violations.push("'" + name + "' is required for " + this.constructor.name);
          }
        } else {
          check = (function() {
            switch (prop.type) {
              case 'string' || 'number' || 'boolean':
                return typeof prop.value === prop.type;
              case 'date':
                if (typeof prop.value === 'string') {
                  prop.value = new Date(prop.value);
                }
                return prop.value instanceof Date;
              case 'array':
                return prop.value instanceof Array;
              default:
                return true;
            }
          })();
          if ((prop.type != null) && !check) {
            violations.push("'" + name + "' must be a " + prop.type);
          }
          if ((prop.model != null) && prop.value instanceof Array && prop.mode !== 2) {
            violations.push("'" + name + "' cannot be an array of " + prop.model);
          }
        }
        if (prop.mode === 2) {
          if (prop.value == null) {
            prop.value = [];
          }
        }
      }
      this.log.debug("done constructing " + this.name);
      assert(violations.length === 0, violations);
    }

    DataStoreModel.prototype.serialize = function(notag) {
      var data, prop, result, x, y, _ref;
      result = {
        id: this.id
      };
      _ref = this.properties;
      for (prop in _ref) {
        data = _ref[prop];
        if (!(data.value != null)) {
          continue;
        }
        x = data.value;
        result[prop] = (function() {
          var _i, _len, _results;
          switch (false) {
            case !(x instanceof DataStoreModel):
              return x.id;
            case !(x instanceof Array):
              _results = [];
              for (_i = 0, _len = x.length; _i < _len; _i++) {
                y = x[_i];
                _results.push(y instanceof DataStoreModel ? y.id : y);
              }
              return _results;
              break;
            default:
              return x;
          }
        })();
      }
      if (notag) {
        return result;
      }
      data = {};
      data["" + this.name] = result;
      return data;
    };

    DataStoreModel.prototype.get = function(property, callback) {
      var cacheComputed, cachedFor, enforce, prop, value, _ref, _ref1;
      assert(this.properties.hasOwnProperty(property), "attempting to retrieve '" + property + "' which doesn't exist in this model");
      prop = this.properties[property];
      enforce = function(x) {
        var err, id, inverse, record, results, val, validator, violations, _ref;
        violations = [];
        validator = prop != null ? (_ref = prop.opts) != null ? _ref.validator : void 0 : void 0;
        val = (function() {
          var _ref1, _ref2;
          switch (false) {
            case !!x:
              if ((_ref1 = prop.opts) != null ? _ref1.required : void 0) {
                violations.push("'" + property + "' is a required property");
              }
              return null;
            case !((prop.model != null) && x instanceof Array && prop.mode === 2):
              results = ((function() {
                var _i, _len, _ref2, _results;
                if (!(id instanceof DataStoreModel)) {
                  _ref2 = prop.value;
                  _results = [];
                  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                    id = _ref2[_i];
                    _results.push(this.store.findRecord(prop.model, id));
                  }
                  return _results;
                }
              }).call(this)).filter(function(e) {
                return e != null;
              });
              if (results.length) {
                return results;
              } else {
                return x;
              }
              break;
            case !((prop.model != null) && x instanceof DataStoreModel):
              switch (prop.mode) {
                case 1:
                  return x;
                case 2:
                  return [x];
              }
              break;
            case !((prop.model != null) && x instanceof Object):
              try {
                inverse = (_ref2 = prop.opts) != null ? _ref2.inverse : void 0;
                if (inverse != null) {
                  x[inverse] = this;
                }
                record = this.store.createRecord(prop.model, x);
              } catch (_error) {
                err = _error;
                this.log.warn({
                  error: err
                }, "attempt to auto-create " + prop.model + " failed");
                record = x;
              }
              return record;
            case !((prop.model != null) && prop.mode !== 3):
              record = this.store.findRecord(prop.model, x);
              if (record == null) {
                violations.push("'" + property + "' must be a model of " + prop.model + ", unable to find using " + x);
              }
              switch (prop.mode) {
                case 1:
                  return record;
                case 2:
                  return [record];
                case 3:
                  return null;
              }
              break;
            case !(x instanceof Array && prop.opts.unique):
              return x.unique();
            default:
              return x;
          }
        }).call(this);
        assert(violations.length === 0, violations);
        if (validator != null) {
          return validator.call(this, val);
        } else {
          return val;
        }
      };
      if (typeof (prop != null ? prop.computed : void 0) === 'function' && this.store.isReady) {
        this.log.debug("issuing get on computed property: %s", property);
        value = prop.value = enforce.call(this, prop.value);
        if (value && this.useCache && prop.cachedOn && (((_ref = prop.opts) != null ? _ref.cache : void 0) !== false)) {
          cachedFor = (new Date() - prop.cachedOn) / 1000;
          if (cachedFor < this.useCache) {
            this.log.info({
              method: 'get',
              property: property,
              id: this.id
            }, "returning cached value: " + value + " will refresh in " + (this.useCache - cachedFor) + " seconds");
            if (typeof callback === "function") {
              callback(null, value);
            }
            return value;
          } else {
            this.log.info({
              method: 'get',
              property: property,
              id: this.id
            }, "re-computing expired cached property (" + cachedFor + " secs > " + this.useCache + " secs)");
          }
        }
        this.log.debug({
          method: 'get',
          property: property,
          id: this.id
        }, "computing a new value!");
        cacheComputed = (function(_this) {
          return function(err, value) {
            if (!(err && _this.useCache)) {
              prop.value = value;
              prop.cachedOn = new Date();
            }
            return typeof callback === "function" ? callback(err, enforce.call(_this, value)) : void 0;
          };
        })(this);
        if ((_ref1 = prop.opts) != null ? _ref1.async : void 0) {
          prop.computed.apply(this, [cacheComputed, prop]);
        } else {
          value = prop.value = prop.computed.apply(this);
          if (typeof callback === "function") {
            callback(null, enforce.call(this, prop.value));
          }
        }
        return value;
      } else {
        this.log.info("issuing get on static property: %s", property);
        if (this.store.isReady) {
          prop.value = enforce.call(this, prop != null ? prop.value : void 0);
        }
        value = prop.value;
        this.log.debug({
          method: 'get',
          property: property,
          id: this.id
        }, "issuing get on " + property + " with " + value);
        if (typeof callback === "function") {
          callback(null, value);
        }
        return value;
      }
    };

    DataStoreModel.prototype.getProperties = function(props, callback) {
      var property, self, start, tasks, value;
      if (typeof props === 'function') {
        callback = props;
        props = this.properties;
      } else {
        if ((props != null) && !(props instanceof Array)) {
          props = [props];
        }
        if (props == null) {
          props = this.properties;
        }
      }
      self = this;
      tasks = {};
      for (property in props) {
        value = props[property];
        if (typeof value.computed === 'function') {
          (function(property) {
            self.log.info("scheduling task for computed property: " + property + "...");
            return tasks[property] = function(callback) {
              return self.get(property, callback);
            };
          })(property);
        }
      }
      start = new Date();
      return async.parallel(tasks, (function(_this) {
        return function(err, results) {
          var data, duration, statics;
          results.id = _this.id;
          _this.log.trace({
            method: 'getProperties',
            id: _this.id,
            results: results
          }, 'computed properties');
          statics = {};
          for (property in props) {
            data = props[property];
            if (!data.computed) {
              statics[property] = _this.get(property);
            }
          }
          _this.log.trace({
            method: 'getProperties',
            id: _this.id,
            statics: statics
          }, 'static properties');
          results = extend(statics, results);
          for (property in results) {
            if (property.indexOf('++') > 0) {
              delete results[property];
            }
          }
          duration = new Date() - start;
          if (duration > 1000) {
            _this.log.warn({
              method: 'getProperties',
              duration: duration,
              numComputed: Object.keys(tasks).length,
              id: _this.id,
              computed: Object.keys(tasks),
              results: results
            }, "processing properties took " + duration + " ms exceeding threshold!");
          }
          _this.log.debug({
            method: 'getProperties',
            id: _this.id,
            results: results
          }, 'final results before callback');
          return callback(results);
        };
      })(this));
    };

    DataStoreModel.prototype.set = function() {
      var ArrayEquals, cval, isDirty, nval, opts, prop, property, setting, value, _base, _i, _j, _len, _ref, _ref1;
      property = arguments[0], opts = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), value = arguments[_i++];
      if ((this.schema != null) && !this.properties.hasOwnProperty(property)) {
        return;
      }
      if (typeof value === 'function') {
        if (property instanceof Array) {
          for (_j = 0, _len = property.length; _j < _len; _j++) {
            prop = property[_j];
            this.properties[prop] = {
              inherit: true
            };
          }
          property = property.join('++');
        }
        if ((_ref = this.properties[property]) != null) {
          _ref.computed = value;
        }
        return (_base = this.properties)[property] != null ? _base[property] : _base[property] = {
          computed: value
        };
      } else {
        ArrayEquals = function(a, b) {
          return a.length === b.length && a.every(function(elem, i) {
            return elem === b[i];
          });
        };
        cval = (_ref1 = this.properties[property]) != null ? _ref1.value : void 0;
        nval = value;
        isDirty = (function() {
          switch (false) {
            case !!this.properties.hasOwnProperty(property):
              return false;
            case cval !== nval:
              return false;
            case !(cval instanceof Array && nval instanceof Array):
              return !ArrayEquals(cval, nval);
            default:
              return true;
          }
        }).call(this);
        this.log.debug({
          method: 'set',
          property: property,
          id: this.id
        }, "compared " + property + " " + cval + " with " + nval + "... isDirty:" + isDirty);
        setting = {
          isDirty: isDirty,
          lvalue: cval,
          value: nval
        };
        if (this.properties.hasOwnProperty(property)) {
          return this.properties[property] = extend(this.properties[property], setting);
        } else {
          return this.properties[property] = setting;
        }
      }
    };

    DataStoreModel.prototype.setProperties = function(obj) {
      var property, value, _results;
      _results = [];
      for (property in obj) {
        value = obj[property];
        _results.push(this.set(property, value));
      }
      return _results;
    };

    DataStoreModel.prototype.update = function(data) {
      var _ref;
      this.setProperties(data);
      if (this.store.isReady) {
        return (_ref = this.controller) != null ? _ref.update(data) : void 0;
      }
    };

    DataStoreModel.prototype.dirtyProperties = function() {
      var data, prop, _ref, _results;
      _ref = this.properties;
      _results = [];
      for (prop in _ref) {
        data = _ref[prop];
        if (data.isDirty) {
          _results.push(prop);
        }
      }
      return _results;
    };

    DataStoreModel.prototype.clearDirty = function() {
      var data, prop, _ref, _results;
      _ref = this.dirtyProperties();
      _results = [];
      for (prop in _ref) {
        data = _ref[prop];
        _results.push(data.isDirty = false);
      }
      return _results;
    };

    DataStoreModel.prototype.isDirty = function(properties) {
      var dirty;
      dirty = this.dirtyProperties();
      if (properties == null) {
        return dirty.length > 0;
      }
      if (!(properties instanceof Array)) {
        properties = [properties];
      }
      dirty = dirty.join(' ');
      return properties.some(function(prop) {
        return ~dirty.indexOf(prop);
      });
    };

    DataStoreModel.prototype.save = function(callback) {
      var state;
      state = (function() {
        switch (false) {
          case !!this.isSaved:
            return 'new';
          case !this.isDirty():
            return 'changed';
          default:
            return 'unchanged';
        }
      }).call(this);
      this.log.info({
        method: 'save',
        id: this.id
      }, "saving a %s record", state);
      if (this.isDirty() || !this.isSaved) {
        return this.getProperties((function(_this) {
          return function(props) {
            var _ref;
            if (props == null) {
              _this.log.error({
                method: 'save',
                id: _this.id
              }, 'failed to retrieve properties following save!');
              return typeof callback === "function" ? callback('save failed to retrieve updated properties!', null) : void 0;
            } else {
              if ((_ref = _this.store) != null) {
                _ref.commit(_this);
              }
              _this.clearDirty();
              _this.isSaved = true;
              return typeof callback === "function" ? callback(null, _this) : void 0;
            }
          };
        })(this));
      }
    };

    DataStoreModel.prototype.destroy = function(callback) {
      var _ref, _ref1;
      if (this.store.isReady) {
        if ((_ref = this.controller) != null) {
          _ref.destroy(data);
        }
      }
      if ((_ref1 = this.store) != null) {
        _ref1.commit(this, true);
      }
      return callback(null, true);
    };

    return DataStoreModel;

  })(SR.Data);

  EventEmitter = require('events').EventEmitter;

  DataStoreController = (function(_super) {
    __extends(DataStoreController, _super);

    function DataStoreController(model, opts) {
      this.model = model;
      assert(model instanceof DataStoreModel, "unable to create an instance of DS.Controller without underlying model!");
      if (model.controller == null) {
        model.controller = this;
      }
      this.store = model.store;
      if (this.store.isReady) {
        this.create(opts != null ? opts.data : void 0);
      }
    }

    DataStoreController.prototype.create = function(data) {
      this.model.set('createdOn', new Date());
      this.model.set('modifiedOn', new Date());
      this.model.set('accessedOn', new Date());
      return this.emit('createRecord', [this.model.name, this.model.id]);
    };

    DataStoreController.prototype.update = function(data) {
      this.model.set('modifiedOn', new Date());
      return this.emit('updateRecord', [this.model, name, this.model.id]);
    };

    DataStoreController.prototype.destroy = function(data) {
      return this.emit('destroyRecord', [this.model.name, this.model.id]);
    };

    return DataStoreController;

  })(EventEmitter);

  DataStore = (function() {
    var async, extend, uuid;

    async = require('async');

    uuid = require('node-uuid');

    extend = require('util')._extend;

    DataStore.prototype.adapters = {};

    DataStore.prototype.adapter = function(type, module) {
      return this.adapters[type] = module;
    };

    DataStore.prototype.using = function(adapter) {
      return this.adapters[adapter];
    };

    function DataStore(opts) {
      var _ref;
      this.log = opts != null ? (_ref = opts.auditor) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.authorizer = opts != null ? opts.authorizer : void 0;
      this.entities = {};
      if ((opts != null ? opts.entities : void 0) != null) {
        this.entities = extend(this.entities, opts.entities);
      }
      this.isReady = false;
    }

    DataStore.prototype.initialize = function() {
      var collection, created, entity, entry, _fn, _i, _len, _ref, _ref1;
      if (this.isReady) {
        return;
      }
      _ref = this.entities;
      for (collection in _ref) {
        entity = _ref[collection];
        entity.registry = new DataStoreRegistry(entity, {
          log: this.log,
          store: this
        });
        if (entity["static"] != null) {
          created = 0;
          _ref1 = entity["static"];
          _fn = (function(_this) {
            return function(entry) {
              var record;
              record = _this.createRecord(entity.name, entry);
              assert(record != null, "" + entry + " failed to be created!");
              if (record != null) {
                record.save();
              }
              if (record != null) {
                return created++;
              }
            };
          })(this);
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            entry = _ref1[_i];
            _fn(entry);
          }
          assert(created === entity["static"].length, "failed to create all the static records!");
          this.log.info({
            collection: collection
          }, "autoloaded " + entity["static"].length + " static records");
        }
      }
      return this.isReady = true;
    };

    DataStore.prototype.contains = function(collection, entity) {
      entity.collection = collection;
      entity.name = entity.model.prototype.name;
      if (entity.persist == null) {
        entity.persist = true;
      }
      if (entity.cache == null) {
        entity.cache = 1;
      }
      if (entity.controller == null) {
        entity.controller = DataStoreController;
      }
      this.entities[entity.name] = entity;
      return this.log.info({
        collection: collection
      }, "registered a collection of '" + collection + "' into the store");
    };

    DataStore.prototype.dump = function() {
      var entity, name, record, records, _ref, _ref1, _results;
      _ref = this.entities;
      _results = [];
      for (name in _ref) {
        entity = _ref[name];
        records = (_ref1 = entity.registry) != null ? _ref1.list() : void 0;
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = records.length; _i < _len; _i++) {
            record = records[_i];
            _results1.push(this.log.info({
              model: name,
              record: record.serialize(),
              method: 'dump'
            }, "DUMP"));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    DataStore.prototype.createRecord = function(type, data) {
      var entity, err, match, record;
      match = this.findRecord(type, data != null ? data.id : void 0);
      if (match != null) {
        return;
      }
      try {
        entity = this.entities[type];
        record = new entity.model(data, {
          store: this,
          log: this.log
        });
        record.useCache = entity.cache;
        record.controller = new entity.controller(record, {
          log: this.log
        });
        this.log.info({
          method: "createRecord",
          id: record.id
        }, 'created a new record for %s', record.constructor.name);
      } catch (_error) {
        err = _error;
        this.log.error(err, "unable to instantiate a new DS.Model for " + type);
        throw err;
      }
      return record;
    };

    DataStore.prototype.deleteRecord = function(type, id, callback) {
      var match;
      match = this.findRecord(type, id);
      if (match == null) {
        callback(null);
      }
      return match.destroy(callback);
    };

    DataStore.prototype.updateRecord = function(type, id, data, callback) {
      return this.find(type, id, (function(_this) {
        return function(err, matches) {
          var record;
          if ((matches != null) && matches.length === 1) {
            record = _this.findRecord(type, matches[0].id);
            record.update(data);
            if (record) {
              return record.save(callback);
            } else {
              return callback(null);
            }
          } else {
            _this.log.warn({
              method: 'updateRecord',
              type: type,
              id: id
            }, 'unable to find existing record to update!');
            return callback(null);
          }
        };
      })(this));
    };

    DataStore.prototype.findRecord = function(type, id) {
      var record, _ref, _ref1;
      if (!((type != null) && (id != null))) {
        return;
      }
      record = (_ref = this.entities[type]) != null ? (_ref1 = _ref.registry) != null ? _ref1.get(id) : void 0 : void 0;
      return record;
    };

    DataStore.prototype.findBy = function(type, condition, callback) {
      var key, records, results, value, _ref, _ref1, _ref2;
      if (!((type != null) && typeof condition === 'object')) {
        return callback("invalid findBy query params!");
      }
      this.log.debug({
        method: 'find',
        type: type,
        condition: condition
      }, 'issuing findBy on requested entity');
      _ref = ((function() {
        var _results;
        _results = [];
        for (key in condition) {
          value = condition[key];
          _results.push([key, value]);
        }
        return _results;
      })())[0], key = _ref[0], value = _ref[1];
      records = ((_ref1 = this.entities[type]) != null ? (_ref2 = _ref1.registry) != null ? _ref2.list() : void 0 : void 0) || [];
      results = records.filter(function(record) {
        var x;
        x = record.get(key);
        return x === value || (x instanceof DataStoreModel && x.id === value);
      });
      if (!((results != null ? results.length : void 0) > 0)) {
        this.log.warn({
          method: 'findBy',
          type: type,
          condition: condition
        }, 'unable to find any records for the condition!');
      } else {
        this.log.debug({
          method: 'findBy',
          type: type,
          condition: condition
        }, 'found %d matching results', results.length);
      }
      return callback(null, results);
    };

    DataStore.prototype.find = function(type, query, callback) {
      var id, self, tasks, _entity, _fn, _i, _len, _ref;
      _entity = this.entities[type];
      if (_entity == null) {
        return callback("DS: unable to find using unsupported type: " + type);
      }
      if (query == null) {
        query = (_ref = _entity.registry) != null ? _ref.keys() : void 0;
      }
      if (!(query instanceof Array)) {
        query = [query];
      }
      self = this;
      tasks = {};
      _fn = function(id) {
        return tasks[id] = function(callback) {
          var match, _ref1;
          match = self.findRecord(type, id);
          if ((match != null) && match instanceof DataStoreModel) {
            return match.getProperties(function(properties) {
              return callback(null, match);
            });
          } else {
            if (((_ref1 = _entity.helpers) != null ? _ref1.get : void 0) == null) {
              return callback(null);
            }
          }
        };
      };
      for (_i = 0, _len = query.length; _i < _len; _i++) {
        id = query[_i];
        _fn(id);
      }
      this.log.info({
        method: 'find',
        type: type,
        query: query
      }, 'issuing find on requested entity');
      return async.parallel(tasks, (function(_this) {
        return function(err, results) {
          var entry, key, matches;
          if (err != null) {
            _this.log.error(err, "error was encountered while performing find operation on " + type + " with " + query + "!");
            return callback(err);
          }
          matches = (function() {
            var _results;
            _results = [];
            for (key in results) {
              entry = results[key];
              if (entry != null) {
                _results.push(entry);
              }
            }
            return _results;
          })();
          if (!((matches != null ? matches.length : void 0) > 0)) {
            _this.log.warn({
              method: 'find',
              type: type,
              query: query
            }, 'unable to find any records matching the query!');
          } else {
            _this.log.debug({
              method: 'find',
              type: type,
              query: query
            }, 'found %d matching results', matches.length);
          }
          return callback(null, matches);
        };
      })(this));
    };

    DataStore.prototype.commit = function(obj, isDestroy) {
      var entity, match, registry, type;
      if (!(obj instanceof DataStoreModel)) {
        return;
      }
      this.log.debug({
        method: "commit",
        record: obj
      });
      registry = ((function() {
        var _ref, _ref1, _results;
        _ref = this.entities;
        _results = [];
        for (type in _ref) {
          entity = _ref[type];
          if (((_ref1 = entity.model) != null ? _ref1.prototype.constructor.name : void 0) === obj.constructor.name) {
            _results.push(entity.registry);
          }
        }
        return _results;
      }).call(this))[0];
      if (!registry) {
        return;
      }
      if (isDestroy == null) {
        isDestroy = false;
      }
      if (obj.id == null) {
        obj.id = uuid.v4();
      }
      match = registry.get(obj.id);
      if (match == null) {
        if (!isDestroy) {
          registry.add(obj.id, obj);
        }
      } else {
        if (!isDestroy) {
          obj.changed = true;
          registry.update(obj.id, obj);
          delete obj.changed;
        } else {
          registry.remove(obj.id);
        }
      }
      this.log.info({
        method: "commit",
        id: obj.id
      }, "updated the store registry for %s", obj.constructor.name);
      return obj;
    };

    return DataStore;

  })();

  module.exports = DataStore;

  module.exports.Model = DataStoreModel;

  module.exports.Controller = DataStoreController;

  module.exports.Registry = DataStoreRegistry;

  module.exports.attr = function(type, opts) {
    return {
      type: type,
      opts: opts
    };
  };

  module.exports.belongsTo = function(model, opts) {
    return {
      mode: 1,
      model: model,
      opts: opts
    };
  };

  module.exports.hasMany = function(model, opts) {
    return {
      mode: 2,
      model: model,
      opts: opts
    };
  };

  module.exports.computed = function(func, opts) {
    return {
      computed: func,
      opts: opts
    };
  };

  module.exports.computedHistory = function(model, opts) {
    return {
      mode: 3,
      model: model,
      opts: opts
    };
  };

}).call(this);
